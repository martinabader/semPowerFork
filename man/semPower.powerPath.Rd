% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convenienceFunctions.R
\name{semPower.powerPath}
\alias{semPower.powerPath}
\title{semPower.powerPath}
\usage{
semPower.powerPath(
  type,
  comparison = "restricted",
  Beta,
  Psi = NULL,
  nullEffect = "beta = 0",
  nullWhich = NULL,
  nullWhichGroups = NULL,
  ...
)
}
\arguments{
\item{type}{type of power analysis, one of \code{'a-priori'}, \code{'post-hoc'}, \code{'compromise'}.}

\item{comparison}{comparison model, either \code{'saturated'} or one of \code{'configural'}, \code{'metric'}, \code{'scalar'}, or a vector of restrictions in \code{lavaan} format (with \code{'none'} for no restrictions). See details.}

\item{Beta}{matrix of regression slopes between latent variables (all-y notation). A list for multiple group models. See details.}

\item{Psi}{variance-covariance matrix of latent residuals when \code{Beta} is specified. If \code{NULL}, a diagonal matrix is assumed. A list for multiple group models. See details.}

\item{nullEffect}{defines the hypothesis of interest, must be one of \code{'beta = 0'} (the default) to test whether a regression slope is zero, \code{'betaX = betaZ'} to test for the equality of slopes, and \code{'betaX = betaZ'} to test for the equality of a slope across groups. Define the slopes to be set to equality in \code{nullWhich} and the groups in \code{nullWhichGroups}.}

\item{nullWhich}{vector of size 2 indicating which slope in \code{Beta} is hypothesized to equal zero when \code{nullEffect = 'beta = 0'}, or to restrict to equality across groups when \code{nullEffect = 'betaA = betaB'}, or list of vectors defining which correlations to restrict to equality when \code{nullEffect = 'betaX = betaZ'}. Can also contain more than two slopes, e.g., \code{list(c(2, 1), c(3, 1), c(3, 2))} to set \code{Beta[2, 1] = Beta[3, 1] = Beta[3, 2]}.}

\item{nullWhichGroups}{for \code{nullEffect = 'betaA = betaB'}, vector indicating the groups for which equality constrains should be applied, e.g. \code{c(1, 3)} to constrain the relevant parameters of the first and the third group. If \code{NULL}, all groups are constrained to equality.}

\item{...}{mandatory further parameters related to the specific type of power analysis requested, see \code{\link[=semPower.aPriori]{semPower.aPriori()}}, \code{\link[=semPower.postHoc]{semPower.postHoc()}}, and \code{\link[=semPower.compromise]{semPower.compromise()}}, and parameters specifying the factor model. See details.}
}
\value{
A list containing the following components is returned:
\item{\code{power}}{the results of the power analysis. Use the \code{summary} method to obtain formatted results.}
\item{\code{Sigma}}{the population covariance matrix. A list for multiple group models.}
\item{\code{mu}}{the population mean vector or \code{NULL} when no meanstructure is involved. A list for multiple group models.}
\item{\code{SigmaHat}}{the H0 model implied covariance matrix. A list for multiple group models.}
\item{\code{muHat}}{the H0 model implied mean vector or \code{NULL} when no meanstructure is involved. A list for multiple group models.}
\item{\code{modelH0}}{\code{lavaan} H0 model string.}
\item{\code{modelH1}}{\code{lavaan} H1 model string or \code{NULL} when the comparison refers to the saturated model.}
}
\description{
Convenience function for performing power analyses for hypothesis arising
in a generic path model.
This requires the lavaan package.
}
\details{
This function performs a power analysis to reject a hypothesis arising
in a generic structural equation model specifying regression relations between the factors via the Beta matrix:
\itemize{
\item \code{nullEffect = 'beta = 0'}: Tests the hypothesis that a slope is zero.
\item \code{nullEffect = 'betaX = betaZ'}: Tests the hypothesis that two or more slopes are equal to each other.
\item \code{nullEffect = 'betaA = betaB'}: Tests the hypothesis that a slope is equal in two or more groups (always assuming metric invariance).
}

This function provides a more generic way to perform power analyses compared to functions covering special cases in a more accessible manner.

A specific hypothesis is defined by setting \code{nullEffect} to define the type of hypothesis,
\code{nullWhich} to define the slope(s) that are targeted, and by providing
the \code{Beta} (and optionally the \code{Psi}) matrix to define the population structure.

To understand the structure of \code{Beta} and \code{Psi}, consider the general structural equation model,
\deqn{\Sigma = \Lambda (I - \Beta)^{-1} \Psi [(I - \Beta)^{-1}]'  \Lambda' + \Theta }
where \eqn{\Beta} is the \eqn{m \cdot m} matrix containing the regression slopes and \eqn{\Psi} is the (residual) variance-covariance matrix of the \eqn{m} factors.

Suppose there are four factors (X1, X2, X3, X4), and Beta is defined as follows:
\eqn{
\begin{array}{lrrr} 
    & X_1 & X_2 & X_3 & X_4\\ 
X_1 & 0.0 & 0.0 & 0.0 & 0.0 \\ 
X_2 & 0.0 & 0.0 & 0.0 & 0.0  \\ 
X_3 & 0.2 & 0.3 & 0.0 & 0.0  \\ 
X_4 & 0.0 & 0.5 & 0.1 & 0.0  \\ 
\end{array}
}

Each row specifies how a particular factor is predicted by the available factors,
so the above implies the following regression relations:

\eqn{
X_1 = 0.0 \cdot X_1 +  0.0 \cdot X_2 + 0.0 \cdot X_3 + 0.0 \cdot X_4 \\
X_2 = 0.0 \cdot X_1 +  0.0 \cdot X_2 + 0.0 \cdot X_3 + 0.0 \cdot X_4 \\
X_3 = 0.2 \cdot X_1 +  0.3 \cdot X_2 + 0.0 \cdot X_3 + 0.0 \cdot X_4 \\
X_4 = 0.3 \cdot X_1 +  0.5 \cdot X_2 + 0.0 \cdot X_3 + 0.0 \cdot X_4 
}

which simplifies to

\eqn{
X_3 = 0.2 \cdot X_1 + 0.3 \cdot X_2
X_4 = 0.3 \cdot X_1 + 0.5 \cdot X_2 
}

Further suppose that Psi is
\eqn{
\begin{array}{lrrr} 
    & X_1 & X_2 & X_3 & X_4\\ 
X_1 & 1.0 & 0.3 & 0.0 & 0.0 \\ 
X_2 & 0.3 & 1.0 & 0.0 & 0.0 \\ 
X_3 & 0.0 & 0.0 & 1.0 & 0.2 \\ 
X_4 & 0.0 & 0.0 & 0.2 & 1.0 \\ 
\end{array}
}
which implies a correlation between X1 and X2 of .3 and a residual correlation
between X3 and X4 of .2.

Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.

Additional arguments related to the \strong{definition of the factor model}:
\itemize{
\item \code{Lambda}: The factor loading matrix (with the number of columns equaling the number of factors).
\item \code{loadings}: Can be used instead of \code{Lambda}: Defines the primary loadings for each factor in a list structure, e. g. \code{loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))} defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
\item \code{nIndicator}: Can be used instead of \code{Lambda}: Used in conjunction with \code{loadM}. Defines the number of indicators by factor, e. g., \code{nIndicator = c(3, 4)} defines a two factor model with three and four indicators for the first and second factor, respectively. \code{nIndicator} can also be a single number to define the same number of indicators for each factor.
\item \code{loadM}: Can be used instead of \code{Lambda}: Used in conjunction with \code{nIndicator}. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. \code{loadM = c(.5, .6)} defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
}

So either \code{Lambda}, or \code{loadings}, or \code{nIndicator} and \code{loadM} always need to be defined.

Additional arguments related to the requested type of \strong{power analysis}:
\itemize{
\item \code{alpha}: The alpha error probability. Required for \code{type = 'a-priori'} and \code{type = 'post-hoc'}.
\item Either \code{beta} or \code{power}: The beta error probability and the statistical power (1 - beta), respectively. Only for \code{type = 'a-priori'}.
\item \code{N}: The sample size. Always required for \code{type = 'post-hoc'} and \code{type = 'compromise'}. For \code{type = 'a-priori'} and multiple group analysis, \code{N} is a list of group weights.
\item \code{abratio}: The ratio of alpha to beta. Only for \code{type = 'compromise'}.
}

Optional arguments if a \strong{simulated power analysis} (\code{simulatedPower = TRUE}) is requested:
\itemize{
\item \code{nReplications}: The number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
\item \code{minConvergenceRate}: The required minimum convergence rate. Defaults to .50.
}
}
\examples{
\dontrun{
# obtain the required N to reject the hypothesis of metric invariance
# in comparison to the configural invariance model 
# with a power of 95\% on alpha = 5\% 
# assuming equally sized groups (N = list(1, 1)) 
# for a factor model involving a single factor which 
# is measured by 5 indicators (in both groups)
# loading by .5 each in the first group and 
# loading by .6 each in the second group.
powerMI <- semPower.powerMI(type = 'a-priori',
                            comparison = 'configural', 
                            nullEffect = 'metric',
                            nIndicator = list(5, 5),
                            loadM = list(.5, .6),
                            alpha = .05, beta = .05, N = list(1, 1))

# show summary
summary(powerMI$power)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerMI$modelH1, sample.cov = list(powerMI$Sigma[[1]], powerMI$Sigma[[2]]),
            sample.nobs = as.list(powerMI$power$requiredN.g), sample.cov.rescale = FALSE)
lavaan::sem(powerMI$modelH0, sample.cov = list(powerMI$Sigma[[1]], powerMI$Sigma[[2]]),
            sample.nobs = as.list(powerMI$power$requiredN.g), sample.cov.rescale = FALSE)

# same as above, but determine power with N = 500 in each group on alpha = .05
powerMI <- semPower.powerMI(type = 'post-hoc',
                            comparison = 'configural', 
                            nullEffect = 'metric',
                            nIndicator = 5,
                            loadM = list(.5, .6),
                            alpha = .05, N = list(500, 500))

# same as above, but determine the critical chi-square with N = 500 in each group so that alpha = beta
powerMI <- semPower.powerMI(type = 'compromise',
                            comparison = 'configural', 
                            nullEffect = 'metric',
                            nIndicator = 5,
                            loadM = list(.5, .6),
                            abratio = 1, N = list(500, 500))

# same as above, but compare to the saturated model
# (rather than to the configural invariance model)
powerMI <- semPower.powerMI(type = 'a-priori',
                            comparison = 'saturated', 
                            nullEffect = 'metric',
                            nIndicator = 5,
                            loadM = list(.5, .6),
                            alpha = .05, beta = .05, N = list(1, 1))

# same as above, but provide individual factor loadings by group using a 
# reduced loading matrix to define a  single factor model with three indicators
# loading by .4, .6, .5 in the first group and 
# loading by .5, .6, .7 in the second group
powerMI <- semPower.powerMI(type = 'a-priori',
                            comparison = 'saturated', 
                            nullEffect = 'metric',
                            loadings = list(
                              list(c(.4, .6, .5)), 
                              list(c(.5, .6, .7))),
                            alpha = .05, beta = .05, N = list(1, 1))

# same as above, but make first group twice as large as the second group 
powerMI <- semPower.powerMI(type = 'a-priori',
                            comparison = 'saturated', 
                            nullEffect = 'metric',
                            loadings = list(
                              list(c(.4, .6, .5)), 
                              list(c(.5, .6, .7))),
                            alpha = .05, beta = .05, N = list(2, 1))

# obtain the required N to reject the hypothesis of scalar invariance
# in comparison to the metric invariance model 
# with a power of 95\% on alpha = 5\% 
# assuming equally sized groups (N = list(1, 1)) 
# for a two factor model, where both factors are  
# measured by 3 indicators each and all loadings equal .5 (in both groups),
# the factor correlation is .3 in both groups, and the
# all intercepts are 0.0 in the first group, but
# all intercepts are 0.1 in the second group
powerMI <- semPower.powerMI(type = 'a-priori',
                            comparison = 'metric', 
                            nullEffect = 'scalar',
                            Phi = list(.3, .3),
                            nIndicator = list(
                              c(3, 3), 
                              c(3, 3)),
                            loadM = .5,
                            tau = list(
                              rep(0.0, 6), 
                              rep(0.1, 6) 
                            ),
                            alpha = .05, beta = .05, N = list(1, 1))

# same as above, but use lavaan group.equal strings 
powerMI <- semPower.powerMI(type = 'a-priori',
                            comparison = c('loadings'), 
                            nullEffect = c('loadings', 'intercepts'),
                            Phi = list(.3, .3),
                            nIndicator = list(
                              c(3, 3), 
                              c(3, 3)),
                            loadM = .5,
                            tau = list(
                              rep(0.0, 6), 
                              rep(0.1, 6) 
                            ),
                            alpha = .05, beta = .05, N = list(1, 1))

# same as above, but
# obtain the required N to reject the hypothesis of equal latent means
# in comparison to the scalar invariance model;
# all intercepts are zero in both groups, 
# in the first group, the latent means equal 0.0, 
# in the second group, the latent mean of the factors are 0.0 and 0.5
powerMI <- semPower.powerMI(type = 'a-priori',
                            comparison = c('loadings', 'intercepts'), 
                            nullEffect = c('loadings', 'intercepts', 'means'),
                            Phi = list(.3, .3),
                            nIndicator = list(
                              c(3, 3), 
                              c(3, 3)),
                            loadM = .5,
                            tau = list(
                              rep(0.0, 6), 
                              rep(0.0, 6) 
                            ),
                            Alpha = list(
                              c(0.0, 0.0),
                              c(0.0, 0.5)
                            ),
                            alpha = .05, beta = .05, N = list(1, 1))

# request a simulated post-hoc power analysis with 500 replications
# to reject the hypothesis of metric invariance.
powerMI <- semPower.powerMI(type = 'post-hoc',
                            comparison = 'configural', 
                            nullEffect = 'metric',
                            nIndicator = list(5, 5),
                            loadM = list(.5, .6),
                            alpha = .05, N = list(500, 500), 
                            simulatedPower = TRUE, nReplications = 500)
                             
}
}
\seealso{
\code{\link[=semPower.genSigma]{semPower.genSigma()}} \code{\link[=semPower.aPriori]{semPower.aPriori()}} \code{\link[=semPower.postHoc]{semPower.postHoc()}} \code{\link[=semPower.compromise]{semPower.compromise()}}
}
